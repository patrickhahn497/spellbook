{"ast":null,"code":"var _jsxFileName = \"/Users/patrickhahn/Documents/GitHub/spellbook/src/components/Feature.js\";\nimport React from 'react'; // so far as I can tell, there are three types of features\n// \t1) Standard (name, text) \n// \t2) features with subfeatures\n// \t3) Features that give spells\n\nfunction returnFeatureWithSubs(feature) {\n  return React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 13\n    },\n    __self: this\n  }, feature.subfeatures.map(subfeature => {\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 17\n      },\n      __self: this\n    }, React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 18\n      },\n      __self: this\n    }, React.createElement(\"b\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 18\n      },\n      __self: this\n    }, subfeature.name)), React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 19\n      },\n      __self: this\n    }, subfeature.text));\n  }));\n}\n\nfunction returnStandardFeature(feature) {\n  return React.createElement(\"h2\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 30\n    },\n    __self: this\n  }, \" \", feature.text, \" \");\n}\n\nfunction returnSpellsFeature(feature) {\n  /* In the future, add a way to only show spells that should show up at your current level */\n  const spells = feature.spells;\n  const keys = Object.keys(spells);\n  return React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 39\n    },\n    __self: this\n  }, React.createElement(\"h3\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 40\n    },\n    __self: this\n  }, \" \", feature.text, \" \"), keys.map(level => {\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 44\n      },\n      __self: this\n    }, React.createElement(\"h3\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 45\n      },\n      __self: this\n    }, level, \": \", spells[0]));\n  }));\n}\n\nconst processFeature = feature => {\n  // if (subfeatures in feature){\n  // \treturn returnFeatureWithSubs;\n  // } else if (spells in feature) {\n  // \treturn returnSpellsFeature;\n  // } else {\n  // \treturn returnStandardFeature;\n  // }\n  if (feature.hasOwnProperty('subfeatures')) {\n    console.log(\"subfeature\");\n    return returnFeatureWithSubs;\n  } else if (feature.hasOwnProperty('spells')) {\n    return returnSpellsFeature;\n  } else {\n    return returnStandardFeature;\n  }\n};\n\nconst Feature = ({\n  levelFeatures\n}) => {\n  return React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 80\n    },\n    __self: this\n  }, React.createElement(\"h1\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 81\n    },\n    __self: this\n  }, \" \", React.createElement(\"b\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 81\n    },\n    __self: this\n  }, levelFeatures.name), \" \"), processFeature(levelFeatures));\n};\n\nexport default Feature;","map":{"version":3,"sources":["/Users/patrickhahn/Documents/GitHub/spellbook/src/components/Feature.js"],"names":["React","returnFeatureWithSubs","feature","subfeatures","map","subfeature","name","text","returnStandardFeature","returnSpellsFeature","spells","keys","Object","level","processFeature","hasOwnProperty","console","log","Feature","levelFeatures"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB,C,CAGA;AACA;AACA;AACA;;AAIA,SAASC,qBAAT,CAA+BC,OAA/B,EAAuC;AACtC,SACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAEEA,OAAO,CAACC,WAAR,CAAoBC,GAApB,CAAyBC,UAAD,IAAgB;AACvC,WACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAIA,UAAU,CAACC,IAAf,CAAJ,CADD,EAEC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAKD,UAAU,CAACE,IAAhB,CAFD,CADD;AAMA,GAPD,CAFF,CADD;AAcA;;AAED,SAASC,qBAAT,CAA+BN,OAA/B,EAAwC;AACvC,SACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAAMA,OAAO,CAACK,IAAd,MADD;AAGA;;AAED,SAASE,mBAAT,CAA6BP,OAA7B,EAAsC;AACrC;AACA,QAAMQ,MAAM,GAAGR,OAAO,CAACQ,MAAvB;AACA,QAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYD,MAAZ,CAAb;AACA,SACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAAMR,OAAO,CAACK,IAAd,MADD,EAGEI,IAAI,CAACP,GAAL,CAAUS,KAAD,IAAW;AACnB,WACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAKA,KAAL,QAAcH,MAAM,CAAC,CAAD,CAApB,CADD,CADD;AAKA,GAND,CAHF,CADD;AAeA;;AAED,MAAMI,cAAc,GAAIZ,OAAD,IAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAIA,OAAO,CAACa,cAAR,CAAuB,aAAvB,CAAJ,EAA0C;AACzCC,IAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ;AACA,WAAOhB,qBAAP;AACA,GAHD,MAGO,IAAIC,OAAO,CAACa,cAAR,CAAuB,QAAvB,CAAJ,EAAsC;AAC5C,WAAON,mBAAP;AACA,GAFM,MAEA;AACN,WAAOD,qBAAP;AACA;AAED,CAjBD;;AAqBA,MAAMU,OAAO,GAAG,CAAC;AAACC,EAAAA;AAAD,CAAD,KAAqB;AAGpC,SACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAIA,aAAa,CAACb,IAAlB,CAAL,MADD,EAEEQ,cAAc,CAACK,aAAD,CAFhB,CADD;AAOA,CAVD;;AAcA,eAAeD,OAAf","sourcesContent":["import React from 'react';\n\n\n// so far as I can tell, there are three types of features\n// \t1) Standard (name, text) \n// \t2) features with subfeatures\n// \t3) Features that give spells\n\n\n\nfunction returnFeatureWithSubs(feature){\n\treturn (\n\t\t<div>\n\t\t\t{\n\t\t\t\tfeature.subfeatures.map((subfeature) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<h3><b>{subfeature.name}</b></h3>\n\t\t\t\t\t\t\t<h3>{subfeature.text}</h3>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t}\n\t\t</div>\n\t);\n}\n\nfunction returnStandardFeature(feature) {\n\treturn (\n\t\t<h2> {feature.text} </h2>\n\t);\n}\n\nfunction returnSpellsFeature(feature) {\n\t/* In the future, add a way to only show spells that should show up at your current level */\n\tconst spells = feature.spells;\n\tconst keys = Object.keys(spells);\n\treturn (\n\t\t<div>\n\t\t\t<h3> {feature.text} </h3>\n\t\t\t{\n\t\t\t\tkeys.map((level) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<h3>{level}: {spells[0]}</h3>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t}\n\t\t</div>\n\n\t);\n}\n\nconst processFeature = (feature) => {\n\t// if (subfeatures in feature){\n\t// \treturn returnFeatureWithSubs;\n\t// } else if (spells in feature) {\n\t// \treturn returnSpellsFeature;\n\t// } else {\n\t// \treturn returnStandardFeature;\n\t// }\n\tif (feature.hasOwnProperty('subfeatures')){\n\t\tconsole.log(\"subfeature\")\n\t\treturn returnFeatureWithSubs;\n\t} else if (feature.hasOwnProperty('spells')) {\n\t\treturn returnSpellsFeature;\n\t} else {\n\t\treturn returnStandardFeature;\n\t}\n\n} \n\n\n\nconst Feature = ({levelFeatures}) => {\n\n\n\treturn (\n\t\t<div>\n\t\t\t<h1> <b>{levelFeatures.name}</b> </h1>\n\t\t\t{processFeature(levelFeatures)}\n\t\t</div>\n\t);\n\n}\n\n\n\nexport default Feature;"]},"metadata":{},"sourceType":"module"}